{"ast":null,"code":"class TreeNode {\n  constructor(name, type) {\n    this.name = name; // 노드의 이름\n    this.type = type; // 노드의 타입 (파일 또는 디렉토리)\n    this.children = []; // 노드의 자식들\n  }\n  addChild(child) {\n    this.children.push(child); // 자식 노드 추가\n  }\n  removeChild(childName) {\n    this.children = this.children.filter(child => child.name !== childName); // 자식 노드 제거\n  }\n}\nclass FileSystem {\n  constructor() {\n    this.root = new TreeNode(\"/\", \"directory\"); // 루트 디렉토리 생성\n  }\n\n  // 파일 생성 메서드\n  createFile(path) {\n    const segments = path.split('/');\n    let current = this.root;\n\n    // 경로를 따라가면서 해당 디렉토리까지 이동\n    for (let i = 1; i < segments.length - 1; i++) {\n      const segment = segments[i];\n      let found = false;\n\n      // 현재 디렉토리의 자식들 중에서 해당 디렉토리를 찾음\n      for (const child of current.children) {\n        if (child.name === segment && child.type === 'directory') {\n          current = child; // 해당 디렉토리로 이동\n          found = true;\n          break;\n        }\n      }\n\n      // 해당 디렉토리가 없으면 오류 발생\n      if (!found) {\n        throw new Error(`Invalid path: ${path}`);\n      }\n    }\n\n    // 파일 노드 생성 및 추가\n    const filename = segments[segments.length - 1];\n    const fileNode = new TreeNode(filename, 'file');\n    current.addChild(fileNode);\n  }\n\n  // 디렉토리 생성 메서드\n  createDirectory(path) {\n    const segments = path.split('/');\n    let current = this.root;\n\n    // 경로를 따라가면서 디렉토리 생성\n    for (let i = 1; i < segments.length; i++) {\n      const segment = segments[i];\n      let found = false;\n\n      // 현재 디렉토리의 자식들 중에서 해당 디렉토리를 찾음\n      for (const child of current.children) {\n        if (child.name === segment && child.type === 'directory') {\n          current = child; // 해당 디렉토리로 이동\n          found = true;\n          break;\n        }\n      }\n\n      // 해당 디렉토리가 없으면 새로운 디렉토리 생성\n      if (!found) {\n        const directoryNode = new TreeNode(segment, 'directory');\n        current.addChild(directoryNode);\n        current = directoryNode;\n      }\n    }\n  }\n\n  // 파일 삭제 메서드\n  deleteFile(path) {\n    const segments = path.split('/');\n    const filename = segments[segments.length - 1];\n    let current = this.root;\n\n    // 경로를 따라가면서 해당 파일을 찾음\n    for (let i = 1; i < segments.length - 1; i++) {\n      const segment = segments[i];\n      let found = false;\n\n      // 현재 디렉토리의 자식들 중에서 해당 디렉토리를 찾음\n      for (const child of current.children) {\n        if (child.name === segment && child.type === 'directory') {\n          current = child; // 해당 디렉토리로 이동\n          found = true;\n          break;\n        }\n      }\n\n      // 해당 디렉토리가 없으면 오류 발생\n      if (!found) {\n        throw new Error(`Invalid path: ${path}`);\n      }\n    }\n\n    // 파일을 삭제\n    current.removeChild(filename);\n  }\n\n  // 디렉토리 삭제 메서드\n  deleteDirectory(path) {\n    const segments = path.split('/');\n    const dirname = segments[segments.length - 1];\n    let current = this.root;\n\n    // 경로를 따라가면서 해당 디렉토리를 찾음\n    for (let i = 1; i < segments.length - 1; i++) {\n      const segment = segments[i];\n      let found = false;\n\n      // 현재 디렉토리의 자식들 중에서 해당 디렉토리를 찾음\n      for (const child of current.children) {\n        if (child.name === segment && child.type === 'directory') {\n          current = child; // 해당 디렉토리로 이동\n          found = true;\n          break;\n        }\n      }\n\n      // 해당 디렉토리가 없으면 오류 발생\n      if (!found) {\n        throw new Error(`Invalid path: ${path}`);\n      }\n    }\n\n    // 디렉토리를 삭제\n    current.removeChild(dirname);\n  }\n\n  // 파일 시스템 출력 메서드\n  printFileSystem() {\n    this._traverseFileSystem(this.root, '');\n  }\n\n  // 파일 시스템을 깊이 우선으로 탐색하면서 출력하는 메서드\n  _traverseFileSystem(node, indent) {\n    console.log(indent + node.name); // 노드 출력\n    // 자식 노드들을 재귀적으로 탐색\n    for (const child of node.children) {\n      this._traverseFileSystem(child, indent + '  ');\n    }\n  }\n\n  // 절대 경로, 상대 경로, 하위 디렉토리의 파일 및 디렉토리 목록을 반환하는 메서드\n  getPathInfo(path) {\n    const segments = path.split('/');\n    let current = this.root;\n    let absolutePath = '/';\n    let relativePath = '';\n    let files = [];\n    let filestype = [];\n\n    // 루트 디렉토리 처리\n    if (path === '/') {\n      relativePath = '/';\n    } else {\n      // 절대 경로와 상대 경로 생성\n      for (let i = 1; i < segments.length; i++) {\n        const segment = segments[i];\n        let found = false;\n        for (const child of current.children) {\n          if (child.name === segment && child.type === 'directory') {\n            current = child;\n            absolutePath += `${segment}/`;\n            relativePath += `${segment}/`;\n            found = true;\n            break;\n          }\n        }\n\n        // 디렉토리가 없는 경우 오류 발생\n        if (!found) {\n          throw new Error(`Invalid path: ${path}`);\n        }\n      }\n    }\n\n    // 현재 디렉토리의 파일 및 디렉토리 목록 생성\n    for (const child of current.children) {\n      if (child.type === 'file' || child.type === 'directory') {\n        files.push(child.name);\n        filestype.push(child.type);\n      }\n    }\n    return {\n      absolutePath,\n      relativePath,\n      files,\n      filestype\n    };\n  }\n  isOverlap(filename, currentPath) {\n    //같은 파일이 존재할시 false반환\n    let found = false;\n    let temp = this.getPathInfo(currentPath).files;\n    for (const key in temp) {\n      console.log(temp[key]);\n      if (temp[key] == filename) {\n        found = true;\n      }\n    }\n    if (found) {\n      return false;\n    } else {\n      return true;\n    }\n  }\n  findDirectory(path) {\n    const segments = path.split('/');\n    const filename = segments[segments.length - 1];\n    let current = this.root;\n    let pathfinder = true;\n    // 경로를 따라가면서 해당 파일을 찾음\n    for (let i = 1; i < segments.length - 1; i++) {\n      const segment = segments[i];\n      let found = false;\n\n      // 현재 디렉토리의 자식들 중에서 해당 디렉토리를 찾음\n      for (const child of current.children) {\n        if (child.name === segment && child.type === 'directory') {\n          current = child; // 해당 디렉토리로 이동\n          found = true;\n          break;\n        }\n      }\n\n      // 해당 디렉토리가 없으면 오류 발생\n      if (!found) {\n        pathfinder = false;\n      }\n    }\n    return pathfinder;\n  }\n}\n// const fs = new FileSystem();\n// fs.createDirectory(\"/root\");\n// fs.createDirectory(\"/tmp\");\n// fs.createDirectory(\"/home/user\")\n// fs.createFile(\"/home/user/file1.txt\");\n// fs.createFile(\"/home/user/file2.txt\");\n// fs.createDirectory(\"/home/user/documents\");\n// fs.createFile(\"/home/user/documents/document1.txt\");\n\n// console.log(fs.printFileSystem());\n\n// fs.deleteDirectory(\"/home/user\");\n\n// console.log(fs.printFileSystem());\n\n// fs.createDirectory(\"/home/user\");\n\n// console.log(fs.printFileSystem());\n\nexport { FileSystem };","map":{"version":3,"names":["TreeNode","constructor","name","type","children","addChild","child","push","removeChild","childName","filter","FileSystem","root","createFile","path","segments","split","current","i","length","segment","found","Error","filename","fileNode","createDirectory","directoryNode","deleteFile","deleteDirectory","dirname","printFileSystem","_traverseFileSystem","node","indent","console","log","getPathInfo","absolutePath","relativePath","files","filestype","isOverlap","currentPath","temp","key","findDirectory","pathfinder"],"sources":["/Users/jeon-aseob/Desktop/NETRUNNER/src/pages/mainPages/tlqkf/fileSystems.js"],"sourcesContent":["class TreeNode {\n    constructor(name, type) {\n        this.name = name;  // 노드의 이름\n        this.type = type;  // 노드의 타입 (파일 또는 디렉토리)\n        this.children = [];  // 노드의 자식들\n    }\n\n    addChild(child) {\n        this.children.push(child);  // 자식 노드 추가\n    }\n\n    removeChild(childName) {\n        this.children = this.children.filter(child => child.name !== childName);  // 자식 노드 제거\n    }\n}\n\nclass FileSystem {\n    constructor() {\n        this.root = new TreeNode(\"/\", \"directory\");  // 루트 디렉토리 생성\n    }\n\n    // 파일 생성 메서드\n    createFile(path) {\n        const segments = path.split('/');\n        let current = this.root;\n\n        // 경로를 따라가면서 해당 디렉토리까지 이동\n        for (let i = 1; i < segments.length - 1; i++) {\n            const segment = segments[i];\n            let found = false;\n\n            // 현재 디렉토리의 자식들 중에서 해당 디렉토리를 찾음\n            for (const child of current.children) {\n                if (child.name === segment && child.type === 'directory') {\n                    current = child;  // 해당 디렉토리로 이동\n                    found = true;\n                    break;\n                }\n            }\n\n            // 해당 디렉토리가 없으면 오류 발생\n            if (!found) {\n                throw new Error(`Invalid path: ${path}`);\n            }\n        }\n\n        // 파일 노드 생성 및 추가\n        const filename = segments[segments.length - 1];\n        const fileNode = new TreeNode(filename, 'file');\n        current.addChild(fileNode);\n    }\n\n    // 디렉토리 생성 메서드\n    createDirectory(path) {\n        const segments = path.split('/');\n        let current = this.root;\n\n        // 경로를 따라가면서 디렉토리 생성\n        for (let i = 1; i < segments.length; i++) {\n            const segment = segments[i];\n            let found = false;\n\n            // 현재 디렉토리의 자식들 중에서 해당 디렉토리를 찾음\n            for (const child of current.children) {\n                if (child.name === segment && child.type === 'directory') {\n                    current = child;  // 해당 디렉토리로 이동\n                    found = true;\n                    break;\n                }\n            }\n\n            // 해당 디렉토리가 없으면 새로운 디렉토리 생성\n            if (!found) {\n                const directoryNode = new TreeNode(segment, 'directory');\n                current.addChild(directoryNode);\n                current = directoryNode;\n            }\n        }\n    }\n\n    // 파일 삭제 메서드\n    deleteFile(path) {\n        const segments = path.split('/');\n        const filename = segments[segments.length - 1];\n        let current = this.root;\n\n        // 경로를 따라가면서 해당 파일을 찾음\n        for (let i = 1; i < segments.length - 1; i++) {\n            const segment = segments[i];\n            let found = false;\n\n            // 현재 디렉토리의 자식들 중에서 해당 디렉토리를 찾음\n            for (const child of current.children) {\n                if (child.name === segment && child.type === 'directory') {\n                    current = child;  // 해당 디렉토리로 이동\n                    found = true;\n                    break;\n                }\n            }\n\n            // 해당 디렉토리가 없으면 오류 발생\n            if (!found) {\n                throw new Error(`Invalid path: ${path}`);\n            }\n        }\n\n        // 파일을 삭제\n        current.removeChild(filename);\n    }\n\n    // 디렉토리 삭제 메서드\n    deleteDirectory(path) {\n        const segments = path.split('/');\n        const dirname = segments[segments.length - 1];\n        let current = this.root;\n\n        // 경로를 따라가면서 해당 디렉토리를 찾음\n        for (let i = 1; i < segments.length - 1; i++) {\n            const segment = segments[i];\n            let found = false;\n\n            // 현재 디렉토리의 자식들 중에서 해당 디렉토리를 찾음\n            for (const child of current.children) {\n                if (child.name === segment && child.type === 'directory') {\n                    current = child;  // 해당 디렉토리로 이동\n                    found = true;\n                    break;\n                }\n            }\n\n            // 해당 디렉토리가 없으면 오류 발생\n            if (!found) {\n                throw new Error(`Invalid path: ${path}`);\n            }\n        }\n\n        // 디렉토리를 삭제\n        current.removeChild(dirname);\n    }\n\n    // 파일 시스템 출력 메서드\n    printFileSystem() {\n        this._traverseFileSystem(this.root, '');\n    }\n\n    // 파일 시스템을 깊이 우선으로 탐색하면서 출력하는 메서드\n    _traverseFileSystem(node, indent) {\n        console.log(indent + node.name);  // 노드 출력\n        // 자식 노드들을 재귀적으로 탐색\n        for (const child of node.children) {\n            this._traverseFileSystem(child, indent + '  ');\n        }\n    }\n\n    // 절대 경로, 상대 경로, 하위 디렉토리의 파일 및 디렉토리 목록을 반환하는 메서드\n    getPathInfo(path) {\n        const segments = path.split('/');\n        let current = this.root;\n        let absolutePath = '/';\n        let relativePath = '';\n        let files = [];\n        let filestype = [];\n\n        // 루트 디렉토리 처리\n        if (path === '/') {\n            relativePath = '/';\n        } else {\n            // 절대 경로와 상대 경로 생성\n            for (let i = 1; i < segments.length; i++) {\n                const segment = segments[i];\n                let found = false;\n\n                for (const child of current.children) {\n                    if (child.name === segment && child.type === 'directory') {\n                        current = child;\n                        absolutePath += `${segment}/`;\n                        relativePath += `${segment}/`;\n                        found = true;\n                        break;\n                    }\n                }\n\n                // 디렉토리가 없는 경우 오류 발생\n                if (!found) {\n                    throw new Error(`Invalid path: ${path}`);\n                }\n            }\n        }\n\n        // 현재 디렉토리의 파일 및 디렉토리 목록 생성\n        for (const child of current.children) {\n            if (child.type === 'file' || child.type === 'directory') {\n                files.push(child.name);\n                filestype.push(child.type);\n            }\n        }\n\n        return { absolutePath, relativePath, files, filestype };\n    }\n    isOverlap(filename, currentPath) { //같은 파일이 존재할시 false반환\n        let found = false;\n        let temp = this.getPathInfo(currentPath).files;\n        for (const key in temp) {\n            console.log(temp[key]);\n            if (temp[key] == filename) {\n                found = true;\n            }\n        }\n        if (found) {\n            return false;\n        } else {\n            return true;\n        }\n    }\n    findDirectory(path) {\n        const segments = path.split('/');\n        const filename = segments[segments.length - 1];\n        let current = this.root;\n        let pathfinder = true;\n        // 경로를 따라가면서 해당 파일을 찾음\n        for (let i = 1; i < segments.length - 1; i++) {\n            const segment = segments[i];\n            let found = false;\n\n            // 현재 디렉토리의 자식들 중에서 해당 디렉토리를 찾음\n            for (const child of current.children) {\n                if (child.name === segment && child.type === 'directory') {\n                    current = child;  // 해당 디렉토리로 이동\n                    found = true;\n                    break;\n                }\n            }\n\n            // 해당 디렉토리가 없으면 오류 발생\n            if (!found) {\n                pathfinder = false;\n            }\n        }\n        return pathfinder;\n    }\n}\n// const fs = new FileSystem();\n// fs.createDirectory(\"/root\");\n// fs.createDirectory(\"/tmp\");\n// fs.createDirectory(\"/home/user\")\n// fs.createFile(\"/home/user/file1.txt\");\n// fs.createFile(\"/home/user/file2.txt\");\n// fs.createDirectory(\"/home/user/documents\");\n// fs.createFile(\"/home/user/documents/document1.txt\");\n\n// console.log(fs.printFileSystem());\n\n// fs.deleteDirectory(\"/home/user\");\n\n// console.log(fs.printFileSystem());\n\n// fs.createDirectory(\"/home/user\");\n\n// console.log(fs.printFileSystem());\n\nexport { FileSystem };\n"],"mappings":"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","ignoreList":[]},"metadata":{},"sourceType":"module","externalDependencies":[]}